---
title: "An exploration into FFmpeg drawtext animations"
excerpt: "How to render and animate text-overlays"
date: "2025-08-10"
tags: ["ffmpeg", "video", "drawtext", "subtitles", "animations"]
---

I‚Äôve been getting deeply into FFmpeg lately. It‚Äôs a remarkable open‚Äësource toolkit and a cornerstone of video/audio processing (consider [donating](https://ffmpeg.org/donations.html) if you can!). Clear guides on text animation are hard to find, so this post aims to walk through the essentials of `drawtext`from timing and positioning to simple animations with scalign and fades and touches on some of the math and the underlying concepts behind them.

FFmpeg provides a few different ways to handle rendering text which include

- SubRip/ASS subtitles (`-vf subtitles`, or `libass`) which are very powerful styling/positioning, rich events, great for full subtitle workflows.
- Image overlays (pre‚Äërendered PNG/SVG) predictable, but not dynamic.
- The `drawtext` filter which can programmaticly render text inside FFmpeg‚Äôs filter graph.

In this post we focus on `drawtext`. It‚Äôs built‚Äëin, expressive, and ideal when you want to:

- Render dynamic text directly in FFmpeg (no external subtitle file)
- Precisely control timing and position per overlay
- Animate properties (opacity, size, x, y, etc.) using FFmpeg‚Äôs expression language

We‚Äôll go from rendering basics and then we'll add some simple animations (fade‚Äëin/out, pop, pop‚Äëbounce), explain the math behind the expressions, and show how to chain multiple text overlays.

## Prerequisites

- FFmpeg with `libfreetype` and `fontconfig` (for fonts)
- A test video: `input.mp4` you can downlooad the video I'll be using [here](https://www.braydenblackwell.com/assets/gwoc.mp4)

A few things to note before we begin...

### Fonts and environments

- System fonts via `font=Sans` require `fontconfig` and an installed font.
- Containers (Alpine, minimal images): install a TTF and use `fontfile=/path.ttf`.
- Paths with spaces need quoting: `fontfile='/path/with space/Font.ttf'`.
- Ensure your FFmpeg has `libfreetype` and `fontconfig`.

### Escaping and quoting

- Colons `:` inside `text=` must be escaped: `\:`
- Backslashes `\` and single quotes `'` inside `text` must be escaped.
- Commas in expressions must be escaped `\,` because filter options are colon‚Äëseparated and commas delimit function arguments.

## How drawtext works

`drawtext` draws a string on every video frame, evaluating parameters each frame:

- Position (`x`, `y`)
- Font (`font` or `fontfile`)
- Size (`fontsize`)
- Color (`fontcolor`)
- Optional effects (shadow, outline, background, alpha)

Example (top‚Äëleft):

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='Hello World':font=Sans:fontsize=48:fontcolor=black:x=50:y=100" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-1.mp4"
  caption="A basic example of rendering text over a video"
/>

Key ideas:

- Coordinates are pixels from the top‚Äëleft.
- You can use expressions referencing frame size (`w`, `h`) and text size (`text_w`, `text_h`).
- Parameters are re‚Äëevaluated per frame, so they can be animated (e.g., make `x` or `alpha` depend on time).

### Centering text

Use `text_w`/`text_h`:

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='Centered':font=Sans:fontsize=64:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2" \
-c:a copy output.mp4
```

Here's an example of how you could offset `200px` from the center on the `y` axis:

```txt
:x=(w-text_w)/2+0 :y=(h-text_h)/2-200
```

## Timing with '**enable**' and time '**t**'

To control when text appears, gate it with `enable='between(t,start,end)'`:

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='This appears at 1s and gone at 4s':font=Sans:fontsize=48:fontcolor=white:
x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,1,4)'" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-2.mp4"
  caption="An example of rendering text between specific timeframes"
/>

- `t` is presentation time (seconds).
- `between(t,1,4)` ‚Üí visible in [1.0, 4.0).

## Expressions 101 (we‚Äôll use this for animation)

FFmpeg expressions use functions like `if(cond, A, B)` and `lt(a,b)`.

Lets take a look at this generic form:

```txt
alpha=if(lt(t,t0),val_before,if(lt(t,t1),val_between,val_after))
```

Lets break down this down peice by peice

- `alpha` = the output value
- `t` = current time
- `t0` and `t1` = two time thresholds (where `t0 < t1`)
- `lt(a,b)` = "less than" function (returns true if `a < b`)
- `if(condition, value_if_true, value_if_false)` = conditional statement

We‚Äôll combine these building blocks to animate alpha (opacity) and fontsize (scale).

## Fade‚Äëin: animating opacity

Goal: fade in over `d` seconds starting at `t0`.

### Math:

- Before `t0`: alpha = 0
- From `t0` to `t0 + d`: alpha = (t - t0) / d
- After `t0 + d`: alpha = 1

Command:

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='This text fades in!':font=Sans:fontsize=64:fontcolor=white:
x=(w-text_w)/2:y=(h-text_h)/2:
alpha=if(lt(t\,1.0)\,0\,if(lt(t\,1.5)\,(t-1.0)/0.5\,1)):
enable='between(t,1.0,5.0)'" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-3.mp4"
  caption="Fade-in over 0.5s starting at 1.0s; visible until 5.0s"
/>

## Fade‚Äëin‚Äëout

Goal: fade in at the start, hold at full opacity, then fade out near the end.

Now all we are going to do is add alinear-deacy phase to here's an example of what this will look like (t0=1.0s, t1=5.0s, d_in=0.3s, d_out=0.3s):

- 0.0‚Äì1.0s: hidden
- 1.0‚Äì1.3s: fade in
- 1.3-4.7s: fully visible
- 4.7‚Äì5.0s: fade out
- 5.0s+: hidden

### Math

- In: (t - t0) / d_in for t ‚àà [t0, t0 + d_in)
- Hold: alpha = 1 for t ‚àà [t0 + d_in, t1 - d_out)
- Out: (t1 - t) / d_out for t ‚àà [t1 - d_out, t1)
- Else: 0

Command:

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='Fade in... and then out!':font=Sans:fontsize=64:fontcolor=white:
x=(w-text_w)/2:y=(h-text_h)/2:
alpha=if(lt(t\,1.0)\,0\,if(lt(t\,1.3)\,(t-1.0)/0.3\,if(lt(t\,4.7)\,1\,if(lt(t\,5.0)\,((5.0-t)/0.3)\,0)))):
enable='between(t,1.0,5.0)'" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-4.mp4"
  caption="Fade-in over 0.3s starting at 1.0s; visible until 4.7s, fade-out over 0.3s"
/>

## Easing equations

Okay before we get into some of the more complicated text animations lets first go over some details about how easing works and why they are good to use when working with animations.

Easing maps normalized time `u` from 0 to 1 into a progress value `y` from 0 to 1. Instead of changing linearly, eases make motion feel more natural (slow in, slow out, or both).

I've created an interactive demo for some of the most common eases that are used in animation to make it easier to visualize.

<EasingPlayground />

## Pop (scale‚Äëin) via fontsize

Let‚Äôs make the text ‚Äúpop‚Äù in, start a bit smaller and quickly grow to its final size. We‚Äôll use a simple ease‚Äëout curve that looks great on almost anything.

### What we‚Äôre doing

- Normalize time inside the intro window: `u = clamp((t - t0)/d, 0, 1)`
- Use a simple ease‚Äëout: `y = sin(œÄ/2 ¬∑ u)`
- Map progress to size: `fontsize = S * (base + gain ¬∑ y)` where `base + gain = 1`
  - In this example, `base = 0.7`, `gain = 0.3` so we ramp from 70% ‚Üí 100%
- Keep it visually centered with `x=(w-text_w)/2:y=(h-text_h)/2` as the text box grows

### Why this ease?

- Sine‚Äëout is smooth: quick at the start, gentle as it settles.
- You can swap in other eases, (quad, cubic, etc.) the normalization + mapping stays the same.

### Math

- `u = clamp((t - t0)/d, 0, 1)`
- `y = sin(œÄ/2 ¬∑ u)`
- `fontsize = S * (0.7 + 0.3 ¬∑ y)`

Command:

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='Pop':font=Sans:
fontsize=if(lt(t\,1.3)\,48*0.7+48*0.3*sin(PI/2*(t-1.0)/0.3)\,48):
fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:
enable='between(t,1.0,4.0)'" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-5.mp4"
  caption="An example of a simple text scale-in animation"
/>

Why `text_w/text_h` shift during pop: since `fontsize` is changing, the text box size changes each frame. Centering with `(w-text_w)/2` keeps it visually centered despite size changes.

## Pop‚Äëbounce (overshoot)

Same idea as the pop, but with a little spice added to it. We overshoot the target size by ~10% and settle back to `S`, a classic ‚Äúbounce‚Äù without complex math.

What we‚Äôre doing

- Use the same normalization and ease‚Äëout: `u = clamp((t - t0)/d, 0, 1)` and `y = sin(œÄ/2 ¬∑ u)`
- Increase the gain during the intro so we peak at ~110%: `fontsize = S * (0.7 + 0.4 ¬∑ y)`
- After the intro window, hold at `S`

Tuning

- Want more snap? Shorten `d`.
- Want a bigger pop? Raise the gain (e.g., `0.45` ‚Üí ~115%).
- Want less? Lower the base (start smaller) or gain (end closer to S sooner).

```bash
ffmpeg -y -i input.mp4 \
-vf "drawtext=text='Pop Bounce':font=Sans:
fontsize=if(lt(t\,1.3)\,48*0.7+48*0.4*sin(PI/2*(t-1.0)/0.3)\,48):
fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:
enable='between(t,1.0,4.0)'" \
-c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-6.mp4"
  caption="An example of a simple text pop-bouce animation"
/>

You can craft other eases or multi‚Äëphase curves by nesting `if(...)` segments (e.g., overshoot then decay). The workflow stays the same: normalize time, choose an ease, map `y` into the property you want to animate.

## Multiple overlays, labels, and word‚Äëby‚Äëword

Each `drawtext` consumes a video stream and outputs a video stream. We chain them by naming labels:

- `[0:v]drawtext=... [v1]; [v1]drawtext=... [v2]; ... -map [v2]`

Sequential words (each 0.5s):

```bash
ffmpeg -y -i input.mp4 -filter_complex "\
[0:v]drawtext=text='One':font=Sans:fontsize=56:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,1.0,1.5)'[v1];\
[v1]drawtext=text='Two':font=Sans:fontsize=56:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,1.5,2.0)'[v2];\
[v2]drawtext=text='Three':font=Sans:fontsize=56:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,2.0,2.5)'[v3];\
[v3]drawtext=text='Four':font=Sans:fontsize=56:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,2.5,3.0)'[vout]" \
-map "[vout]" -map "0:a?" -c:v libx264 -crf 23 -preset medium -c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-7.mp4"
  caption="An example of sequentially rendering words"
/>

Add per‚Äëword fade‚Äëin/out by including the `alpha=...` expression in each block.

## Styling: shadows, outlines, backgrounds

- Shadow:
  ```
  :shadowcolor=black:shadowx=2:shadowy=2
  ```
- Outline:
  ```
  :bordercolor=black:borderw=2
  ```
- Background box (with opacity):
  ```
  :box=1:boxcolor=black@0.5
  ```

These are additive, you can combine with alpha/fonstize animations.

Cross‚Äëplatform tip:

- Prefer wrapping the entire `-vf` in double quotes, then escape commas as shown.

## Performance and complexity

Each `drawtext` is a filter node. Many nodes ‚Üí complex graphs ‚Üí slower and can hit filter‚Äëgraph limits.

Here are some of the different strategies I've used:

- Merge multiple words into fewer overlays when possible.
- Pre‚Äërender heavy text sequences and overlay the result.
- Use multiple passes if your chain becomes very long (render video, then overlay more text on the output).
- Keep files short while testing; scale to final length once the logic is correct.

## Putting it together ‚Äî title + subtitle (sequenced)

Let‚Äôs finish with a clean title card: the main title fades in, holds, fades out, and the subtitle follows shortly after with the same timing. We‚Äôll keep a soft drop shadow for legibility and center both lines.

```bash
ffmpeg -y -i input.mp4 -filter_complex "\
[0:v]drawtext=text='The Great Wall of China':font=Sans:fontsize=72:fontcolor=white:shadowcolor=black:shadowx=2:shadowy=2:\
  x=(w-text_w)/2:y=(h-text_h)/2-40:\
  alpha=if(lt(t\,1.0)\,0\,if(lt(t\,1.3)\,(t-1.0)/0.3\,if(lt(t\,3.7)\,1\,if(lt(t\,4.0)\,((4.0-t)/0.3)\,0)))):\
  enable='between(t,1.0,4.0)'[v1];\
[v1]drawtext=text='A Wonder of the World':font=Sans:fontsize=40:fontcolor=white:shadowcolor=black:shadowx=2:shadowy=2:\
  x=(w-text_w)/2:y=(h-text_h)/2+40:\
  alpha=if(lt(t\,1.4)\,0\,if(lt(t\,1.7)\,(t-1.4)/0.3\,if(lt(t\,4.1)\,1\,if(lt(t\,4.4)\,((4.4-t)/0.3)\,0)))):\
  enable='between(t,1.4,4.4)'[vout]" \
-map "[vout]" -map "0:a?" -c:v libx264 -crf 23 -preset medium -c:a copy output.mp4
```

<Video
  src="https://7llpl63xkl8jovgt.public.blob.vercel-storage.com/ffmpeg-text-rendering/output-video-8.mp4"
  caption="A sequenced title and subtitle with staggered fade-in/out"
/>

Notes

- Title window: [1.0, 4.0) with 0.3s in/out; subtitle is offset by +0.4s ‚Üí [1.4, 4.4)
- Both are centered; the title is raised by 40px, the subtitle lowered by 40px to sit as a pair
- You can adjust the offsets, durations, and sizes to taste; the fade logic stays the same

## Conclusion

You‚Äôve seen how `drawtext`:

- Renders text with flexible positioning (`x`, `y`, `text_w`, `text_h`)
- Uses `enable='between(t,...)'` for timeline gating
- Animates properties (opacity with `alpha`, size with `fontsize`) using the `if(...)` expression language
- Chains multiple overlays with labels for sequences like word‚Äëby‚Äëword titles

These primitives (piecewise alpha, time‚Äënormalized eases, label chaining) scale to many effects:

- Slide‚Äëin/out (animate `x`/`y`)
- Typewriter (progressively reveal substrings or overlay per‚Äëchar frames)
- Emphasis pulses (periodic size/alpha modulation)
- Complex sequences (precompute windows, chain filters, or render in passes)

If you later outgrow `drawtext` for typography/layout, look at ASS/`libass`. The timing concepts are the same ‚Äî you‚Äôll just author events/styling in a subtitle format and let the renderer handle layout.

As a closing note, I‚Äôve had a lot of fun digging into FFmpeg lately. It‚Äôs wildly capable, but once you start compositing multiple streams, juggling transitions, keeping background music from stepping on dialog, and making sure fades don‚Äôt interfere with other audio... the filter graphs can get hairy fast. I‚Äôve started a tiny Node.js helper to make these workflows simpler and safer: [`simple-ffmpeg`](https://github.com/Fats403/simple-ffmpeg). I‚Äôd love your feedback, ideas, or PRs if this space interests you.

Happy rendering! üòÄ
